# UnifiedSubnautica: New Mod Authoring Guide

This guide walks you through creating a new mod in this repository, wiring it into our solution/build pipeline, and shaping prompts so Copilot can automate most of the work. It’s based on the AutoScanningChip work you just completed.

## TL;DR checklist

- Create folder: `MrPurple6411-Subnautica-Mods/<ModName>/`
- Add `<ModName>.csproj` (net472, Version, OutputPath) — use any sibling mod as a template
- Add a `Main.cs` with a BepInEx plugin, Nautilus registration, and game process attributes
- Add to `UnifiedVSSolution.sln` and ensure both Build.0 entries (Subnautica/BelowZero)
- Build with `build-all.ps1 -Subnautica` (and/or `-BelowZero`) — a zip appears in `Zips_<Config>/`
- Optional: add Nautilus ConfigFile options, Harmony patches, tests, and docs

## Repository conventions

- Target frameworks: net472 for both games
- Configurations: `Subnautica`, `BelowZero`
- Common msbuild settings live in `Directory.Build.props` and `Directory.Build.targets`:
  - References the correct Nautilus package per configuration
  - Normalizes output to `bin/<Config>/<ProjectName>/`
  - Post-build zip to `Zips_<Config>/<AssemblyName>_<Config>_v<Version>.zip`
- Build orchestration:
  - `build-all.ps1` regenerates solution filters and builds selected configurations
  - `Tools/Build-Report-*.ps1` run a build and write summary reports to `docs/build-status/*`
  - `manage-versions.ps1` scans `bin` outputs and maintains `mod-versions.json`

## Project structure template

Minimal layout for a new mod named `MyNewMod`:

```
MrPurple6411-Subnautica-Mods/
  MyNewMod/
    MyNewMod.csproj
    Main.cs
    Properties/
      MyPluginInfo.cs (auto-generated by BepInEx.PluginInfoProps)
    README.md (optional)
```

### Example csproj

Use an existing mod’s csproj as a reference (e.g., CopperFromScanning). Key points:

- Keep `<TargetFramework>` and package references in `Directory.Build.props`
- Set AssemblyName, Product, Version, and OutputPath

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <AssemblyName>MyNewMod</AssemblyName>
    <Product>My New Mod</Product>
    <Version>1.0.0</Version>
    <OutputPath>$(SolutionDir)bin\$(Configuration)\$(AssemblyName)\</OutputPath>
  </PropertyGroup>
</Project>
```

### Starter Main.cs

- Use BepInEx + Nautilus; target the correct process via preprocessor symbols
- Register content in Awake

```csharp
namespace MyNewMod;

using BepInEx;
using Nautilus.Assets;
using Nautilus.Assets.Gadgets;
using Nautilus.Assets.PrefabTemplates;
using Nautilus.Crafting;
using Nautilus.Handlers;
using Nautilus.Utility;
using UnityEngine;

[BepInPlugin(MyPluginInfo.PLUGIN_GUID, MyPluginInfo.PLUGIN_NAME, MyPluginInfo.PLUGIN_VERSION)]
[BepInDependency(Nautilus.PluginInfo.PLUGIN_GUID)]
#if SUBNAUTICA
[BepInProcess("Subnautica.exe")]
#elif BELOWZERO
[BepInProcess("SubnauticaZero.exe")]
#endif
public class Main : BaseUnityPlugin
{
  private void Awake()
  {
    // Register assets / prefabs / options here
  }
}
```

## Adding the project to the solution

Our solution filters (`Subnautica.slnf` / `BelowZero.slnf`) are auto-generated based on the Build.0 entries in `UnifiedVSSolution.sln`. So:

- Add the new csproj to `UnifiedVSSolution.sln`
- Ensure entries exist in the `ProjectConfigurationPlatforms` section:
  - `<GUID>.Subnautica|Any CPU.ActiveCfg = Subnautica|Any CPU`
  - `<GUID>.Subnautica|Any CPU.Build.0 = Subnautica|Any CPU`
  - `<GUID>.BelowZero|Any CPU.ActiveCfg = BelowZero|Any CPU`
  - `<GUID>.BelowZero|Any CPU.Build.0 = BelowZero|Any CPU`

Once it’s in the `.sln`, the generator scripts will include it in the `.slnf` and the build will pick it up.

## Building and outputs

- Build all or per-game:
  - `./build-all.ps1 -Subnautica`
  - `./build-all.ps1 -BelowZero`
- Output DLL: `bin/<Config>/<ProjectName>/<AssemblyName>.dll`
- Zip artifact: `Zips_<Config>/<AssemblyName>_<Config>_v<Version>.zip`
- Reports: `docs/build-status/<Config>/summary-*.{json,md}`

## Nautilus config and options (pattern)

- Derive a config class from `Nautilus.Json.ConfigFile`
- Add `[Menu("Display Name")]` and options with `[Toggle]`, `[Slider]`, etc.
- Register in `Main.Awake()` with `OptionsPanelHandler.RegisterModOptions<TConfig>()`
- Use the config in Harmony patches or runtime logic

Example:

```csharp
[Menu("My New Mod")]
public class Config : Nautilus.Json.ConfigFile
{
  [Toggle("Enable Feature")]
  public bool EnableFeature = false; // default false
}

// In Awake()
var cfg = OptionsPanelHandler.RegisterModOptions<Config>();
```

## Harmony patching

- Use Harmony in your plugin class or a static Patcher class
- Keep patches small and guard with config toggles

```csharp
var harmony = new Harmony(MyPluginInfo.PLUGIN_GUID);
// harmony.PatchAll(typeof(SomePatch).Assembly);
```

## Copilot prompt patterns that work well here

- “Create a new mod project named X under `MrPurple6411-Subnautica-Mods/X/` with csproj similar to CopperFromScanning; target net472; Subnautica/BelowZero configs via Directory props; zip outputs like other mods.”
- “In `Main.cs`, register a CustomPrefab by cloning TechType.Y, equipable to EquipmentType.Z, with a simple recipe; wire into Fabricator.”
- “Add a Nautilus ConfigFile with a default-false toggle named Foo. Hook the toggle in the Harmony patch at P.Q method to early-out.”
- “Add the new project to `UnifiedVSSolution.sln` with Build.0 for Subnautica and BelowZero; regenerate slnf and build Subnautica only.”
- “Ensure outputs go to `bin/<Config>/<ProjectName>/` and zipped as in `Directory.Build.targets`.”

When asking Copilot to edit files, specify exact paths, names, and desired code blocks. When the task spans multiple files, ask it to do the end-to-end wiring and then run the Subnautica build task.

## Testing tips

- Start small: build the Subnautica configuration first to check references
- If a compile error references Nautilus types, ensure the configuration matches (Subnautica vs BelowZero package) and that preprocessor `#if` guards are correct
- Use the `Tools/Build-Report-*` scripts to get quick per-project status and sample errors

## Versioning workflow

- After a successful build, run:
  - `manage-versions.ps1 -CheckForChanges` to see what changed/new
  - `manage-versions.ps1 -UpdateVersions` to bump versions and update hashes
  - Or `manage-versions.ps1 -SyncOnline -SelectiveBuild` to fetch baseline, rebuild changed configs, and update `mod-versions.json`

## Common pitfalls

- Forgetting to add the project to `UnifiedVSSolution.sln` (it won’t appear in `.slnf` or builds)
- Missing Build.0 entries for one of the configurations (only one game builds)
- Output paths inconsistent with repo standard (breaks report/versioning tooling)
- Using Nautilus APIs without the correct per-game package (let the Directory props inject it)

## Example: AutoScanningChip highlights

- Equipable chip cloned from MapRoomHUDChip using Nautilus `CustomPrefab` + `CloneTemplate`
- Manager component attached to Player adds a trigger `SphereCollider` and force-unlocks PDAScanner/KnownTech on contact
- Trigger adds a kinematic Rigidbody only if the Player hierarchy doesn’t already have one
- Range scales with number of chips equipped via `Inventory.main.equipment.GetCount`
- KnownTech/PDAScanner behavior mirrors the UnknownName “scan-on-pickup” logic

---

With this guide, you can prompt Copilot to scaffold new mods quickly, wire them into the solution, and get consistent build artifacts and reports without manual guesswork.
